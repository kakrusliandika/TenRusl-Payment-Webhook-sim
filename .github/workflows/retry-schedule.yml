name: Retry Webhook Events (Scheduled)

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:
    inputs:
      provider:
        description: "Filter provider (kosong = semua)"
        required: false
        default: ""
      limit:
        description: "Batch limit"
        required: false
        default: "200"
      max_attempts:
        description: "Max attempts"
        required: false
        default: "5"
      mode:
        description: "Backoff mode: full|equal|decorrelated"
        required: false
        default: "full"
      force:
        description: "Force retry (abaikan next_retry_at / max attempts). true|false"
        required: false
        default: "false"
      queue:
        description: "Dispatch ke queue (true) atau inline (false)"
        required: false
        default: "false"
      queue_name:
        description: "Queue name (jika queue=true)"
        required: false
        default: "webhooks"

concurrency:
  # Pastikan hanya 1 run aktif untuk workflow ini dalam 1 repo
  group: tenrusl-retry-${{ github.repository }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  retry:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    env:
      # Runtime Laravel
      APP_ENV: production
      APP_DEBUG: "false"
      LOG_CHANNEL: stderr
      LOG_LEVEL: info

      # Wajib: gunakan Redis untuk lock (multi-run safe)
      CACHE_STORE: redis

      # Workflow ini tidak menjalankan queue worker; default sinkron
      QUEUE_CONNECTION: sync
      SESSION_DRIVER: array

      # ======= Secrets (set di GitHub → Settings → Secrets and variables) =======
      APP_KEY: ${{ secrets.APP_KEY }}

      DB_CONNECTION: ${{ secrets.DB_CONNECTION }}
      DB_HOST: ${{ secrets.DB_HOST }}
      DB_PORT: ${{ secrets.DB_PORT }}
      DB_DATABASE: ${{ secrets.DB_DATABASE }}
      DB_USERNAME: ${{ secrets.DB_USERNAME }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

      REDIS_HOST: ${{ secrets.REDIS_HOST }}
      REDIS_PORT: ${{ secrets.REDIS_PORT }}
      REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.3"
          coverage: none
          tools: composer
          extensions: mbstring, dom, fileinfo, intl, pcntl, pdo, pdo_mysql, pdo_pgsql, redis

      - name: Validate composer.json
        run: composer validate --no-check-publish

      - name: Cache Composer
        uses: actions/cache@v4
        with:
          path: ~/.composer/cache/files
          key: composer-${{ runner.os }}-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            composer-${{ runner.os }}-

      - name: Install Dependencies (prod-only)
        run: composer install --prefer-dist --no-interaction --no-progress --no-dev --optimize-autoloader

      - name: Sanity check required env
        run: |
          if [ -z "${APP_KEY:-}" ]; then
            echo "APP_KEY is required (set secrets.APP_KEY)."
            exit 1
          fi
          if [ -z "${DB_CONNECTION:-}" ]; then
            echo "DB_CONNECTION is required."
            exit 1
          fi

      # Tidak ada migrasi di workflow schedule (migrasi = langkah rilis terpisah)
      - name: Execute Retry Processor
        env:
          RETRY_PROVIDER: ${{ inputs.provider }}
          RETRY_LIMIT: ${{ inputs.limit }}
          RETRY_MAX_ATTEMPTS: ${{ inputs.max_attempts }}
          RETRY_BACKOFF_MODE: ${{ inputs.mode }}
          RETRY_FORCE: ${{ inputs.force }}
          RETRY_QUEUE: ${{ inputs.queue }}
          RETRY_QUEUE_NAME: ${{ inputs.queue_name }}
        run: |
          LIMIT="${RETRY_LIMIT:-200}"
          MAX_ATTEMPTS="${RETRY_MAX_ATTEMPTS:-5}"
          MODE="${RETRY_BACKOFF_MODE:-full}"
          PROVIDER="${RETRY_PROVIDER:-}"
          FORCE="${RETRY_FORCE:-false}"
          QUEUE="${RETRY_QUEUE:-false}"
          QUEUE_NAME="${RETRY_QUEUE_NAME:-webhooks}"

          CMD="php artisan tenrusl:webhooks:retry --limit=${LIMIT} --max-attempts=${MAX_ATTEMPTS} --mode=${MODE}"
          if [ -n "${PROVIDER}" ]; then
            CMD="${CMD} --provider=${PROVIDER}"
          fi
          if [ "${FORCE}" = "true" ]; then
            CMD="${CMD} --force"
          fi
          if [ "${QUEUE}" = "true" ]; then
            CMD="${CMD} --queue --queue-name=${QUEUE_NAME}"
          fi

          echo "Running: ${CMD}"
          ${CMD}
